import { createHash } from "node:crypto";
import type { VoiceprintId, VoiceprintIdConfig, SpeakerSegment } from "./types.js";

/**
 * Default configuration for voiceprint ID generation
 */
const DEFAULT_CONFIG: VoiceprintIdConfig = {
  algorithm: "sha256",
  vectorNormalization: "l2",
  outputFormat: "vpr_{hash}",
  hashTruncation: 32,
};

/**
 * Generate a deterministic voiceprint ID from speaker segments
 *
 * This function creates a unique, deterministic ID based on the speaker's
 * audio characteristics. The ID is generated by:
 * 1. Extracting features from speaker segments (timing, text patterns)
 * 2. Normalizing the feature vector
 * 3. Computing SHA-256 hash
 * 4. Truncating and adding prefix
 *
 * @param segments - Array of speaker segments for this speaker
 * @param speakerId - The speaker ID (0, 1, 2, etc.)
 * @param config - Optional configuration for ID generation
 * @returns A deterministic voiceprint ID in format "vpr_<32-char-hash>"
 *
 * @example
 * ```typescript
 * const segments = [
 *   { speakerId: 0, startTime: 0, endTime: 2.5, text: "Hello world" },
 *   { speakerId: 0, startTime: 5, endTime: 7, text: "How are you?" }
 * ];
 * const id = generateVoiceprintId(segments, 0);
 * // Returns: "vpr_a1b2c3d4e5f6..." (32 char hash)
 * ```
 */
export function generateVoiceprintId(
  segments: SpeakerSegment[],
  speakerId: number,
  config: Partial<VoiceprintIdConfig> = {},
): VoiceprintId {
  const fullConfig: VoiceprintIdConfig = { ...DEFAULT_CONFIG, ...config };

  // Filter segments for this speaker and sort by time
  const speakerSegments = segments
    .filter((s) => s.speakerId === speakerId)
    .sort((a, b) => a.startTime - b.startTime);

  if (speakerSegments.length === 0) {
    // Fallback: generate ID from speaker ID only
    const fallbackData = `speaker_${speakerId}_${Date.now()}`;
    const fallbackHash = createHash(fullConfig.algorithm)
      .update(fallbackData)
      .digest("hex")
      .slice(0, fullConfig.hashTruncation);
    return fullConfig.outputFormat.replace("{hash}", fallbackHash) as VoiceprintId;
  }

  // Extract features from segments
  const features = extractFeatures(speakerSegments, speakerId);

  // Normalize feature vector (L2 normalization)
  const normalizedFeatures = l2Normalize(features);

  // Serialize to binary format
  const serialized = serializeFeatures(normalizedFeatures);

  // Compute SHA-256 hash
  const hash = createHash(fullConfig.algorithm).update(serialized).digest("hex");

  // Truncate to specified length
  const truncatedHash = hash.slice(0, fullConfig.hashTruncation);

  // Format output
  return fullConfig.outputFormat.replace("{hash}", truncatedHash) as VoiceprintId;
}

/**
 * Extract feature vector from speaker segments
 *
 * Features extracted:
 * - Temporal features (total duration, segment count, avg segment length)
 * - Text-based features (character count, word count, avg word length)
 * - Timing patterns (gaps between segments, speaking rate)
 */
function extractFeatures(segments: SpeakerSegment[], speakerId: number): number[] {
  const features: number[] = [];

  // 1. Temporal features
  const totalDuration = segments.reduce((sum, s) => sum + (s.endTime - s.startTime), 0);
  const segmentCount = segments.length;
  const avgSegmentLength = segmentCount > 0 ? totalDuration / segmentCount : 0;

  features.push(totalDuration, segmentCount, avgSegmentLength);

  // 2. Text-based features
  let totalChars = 0;
  let totalWords = 0;

  for (const segment of segments) {
    totalChars += segment.text.length;
    totalWords += segment.text.split(/\s+/).filter((w) => w.length > 0).length;
  }

  const avgWordLength = totalWords > 0 ? totalChars / totalWords : 0;
  const avgWordsPerSegment = segmentCount > 0 ? totalWords / segmentCount : 0;

  features.push(totalChars, totalWords, avgWordLength, avgWordsPerSegment);

  // 3. Timing patterns
  if (segments.length > 1) {
    let totalGap = 0;
    for (let i = 1; i < segments.length; i++) {
      totalGap += segments[i].startTime - segments[i - 1].endTime;
    }
    const avgGap = totalGap / (segments.length - 1);
    const speakingRate = totalDuration > 0 ? totalWords / totalDuration : 0;

    features.push(avgGap, speakingRate);
  } else {
    features.push(0, 0); // No gaps for single segment
  }

  // 4. Speaker ID (normalized)
  features.push(speakerId);

  return features;
}

/**
 * Apply L2 normalization to feature vector
 * This ensures the vector has unit length, making the hash
 * invariant to the scale of the features
 */
function l2Normalize(vector: number[]): number[] {
  const squaredSum = vector.reduce((sum, val) => sum + val * val, 0);
  const magnitude = Math.sqrt(squaredSum);

  if (magnitude === 0) {
    // Return zero vector if magnitude is 0
    return vector.map(() => 0);
  }

  return vector.map((val) => val / magnitude);
}

/**
 * Serialize feature vector to binary format
 * Uses 8-byte double precision floating point numbers
 */
function serializeFeatures(vector: number[]): Buffer {
  const buffer = Buffer.alloc(vector.length * 8);
  for (let i = 0; i < vector.length; i++) {
    buffer.writeDoubleLE(vector[i], i * 8);
  }
  return buffer;
}

/**
 * Validate a voiceprint ID format
 *
 * @param id - The ID to validate
 * @returns True if the ID is a valid voiceprint ID
 */
export function isValidVoiceprintId(id: string): id is VoiceprintId {
  return typeof id === "string" && /^vpr_[a-f0-9]{32}$/i.test(id);
}

/**
 * Extract speaker ID from voiceprint ID
 * Note: This is not reversible - the hash is one-way
 * This function is mainly for debugging/logging purposes
 *
 * @param voiceprintId - The voiceprint ID
 * @returns The hash portion of the ID
 */
export function extractVoiceprintHash(voiceprintId: VoiceprintId): string {
  return voiceprintId.slice(4); // Remove "vpr_" prefix
}
